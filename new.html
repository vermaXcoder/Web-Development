<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave Torus</title>
    <style>
         body { margin: 0; 
        background-color: black; 
        display: flex; 
        justify-content: center; 
        align-items: center; 
        height: 100vh;
        margin: 0; 
        outline: none;
        background: #000;
        -webkit-tap-highlight-color: transparent;
        }
        canvas { display: block; }
        #infoButton {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            user-select: none;
        }

        .info-popup {
            display: none;
            position: absolute;
            top: 40px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 5px;
            width: 300px;
            text-align: left;
            user-select: none;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <button id="infoButton">&#9432;</button>
    <div class="info-popup" id="infoPopup">
        <p style="text-align:center;" ><strong>Wave Torus</strong></p>
    <p style="color:pink; text-align: center;">A Wave Torus is a variation of a standard torus (a doughnut-shaped surface) that incorporates a wave-like modulation along its surface. This modulation creates a rippled or undulating effect, giving the torus a more complex and visually interesting shape. The Wave Torus can be used in various fields such as computer graphics, architectural design, and artistic visualization to create intricate and dynamic 3D models.</p>
            <p style="text-align:center;">For Equations visit my Github. Enjoy!</p>
    </div>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Parameters for the Wave Torus
        const R = 6, r = 0.8, a = 2.2, n = 8;
        const segments = 100;

        // Create the geometry
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const indices = [];

        for (let u = 0; u <= segments; u++) {
            for (let v = 0; v <= segments; v++) {
                const uAngle = (u / segments) * 2 * Math.PI;
                const vAngle = (v / segments) * 2 * Math.PI;

                const x = (R + (r + a * Math.sin(n * uAngle)) * Math.cos(vAngle)) * Math.cos(uAngle);
                const y = (R + (r + a * Math.sin(n * uAngle)) * Math.cos(vAngle)) * Math.sin(uAngle);
                const z = (r + a * Math.sin(n * uAngle)) * Math.sin(vAngle);

                vertices.push(x, y, z);
            }
        }

        for (let u = 0; u < segments; u++) {
            for (let v = 0; v < segments; v++) {
                const i = u * (segments + 1) + v;
                const j = i + segments + 1;

                indices.push(i, j, i + 1);
                indices.push(j, j + 1, i + 1);
            }
        }

        geometry.setIndex(indices);
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

        // Rainbow shader material
        const vertexShader = `
            varying vec3 vPosition;
            void main() {
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            varying vec3 vPosition;
            void main() {
                float hue = atan(vPosition.z, vPosition.x) / (2.0 * 3.14159265359) + 0.5;
                vec3 color = vec3(
                    abs(hue - 0.5) * 2.0,
                    1.0 - abs(hue - 0.5) * 2.0,
                    hue
                );
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        const material = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            wireframe: true
        });

        const waveTorus = new THREE.Mesh(geometry, material);
        scene.add(waveTorus);

        // Create starfield
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        const starColors = [];

        for (let i = 0; i < 1000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;

            starVertices.push(x, y, z);

            const color = new THREE.Color();
            color.setHSL(Math.random(), 1.0, 0.7);
            starColors.push(color.r, color.g, color.b);
        }

        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));

        const starMaterial = new THREE.PointsMaterial({ size: 0.9, vertexColors: true });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Camera position
        camera.position.z = 25;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            waveTorus.rotation.x += 0.01;
            waveTorus.rotation.y += 0.01;

            // Animate stars
            const positions = starGeometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] -= 0.1; // Move stars downwards
                if (positions[i + 1] < -1000) positions[i + 1] = 1000; // Reset star position
            }
            starGeometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();
        
         $("#infoButton").click(function() {
            $("#infoPopup").fadeToggle();
        });
    </script>
    <a href="https://github.com/http406/Wave-Torus/" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</body>
</html>